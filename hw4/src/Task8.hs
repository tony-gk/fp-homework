{-# LANGUAGE InstanceSigs #-}
module Task8
  ( initSimulation
  , step
  , showSimulation
  ) where

import Control.Comonad (Comonad (..))
import System.Random (StdGen, newStdGen, random, split)

-- | Representation of a list focused on a single element.
data ListZipper a = LZ [a] a [a]

-- | Returns the zipper with the focus shifted left one element.
listLeft :: ListZipper a -> ListZipper a
listLeft (LZ (l: ls) a rs) = LZ ls l (a : rs)
listLeft _                 = error "Empty left part"

-- | Returns the zipper with the focus shifted right one element.
listRight :: ListZipper a -> ListZipper a
listRight (LZ ls a (r : rs)) = LZ (a : ls) r rs
listRight _                  = error "Empty right part"

-- | 'iterate' @f x@ returns tail of an infinite list of repeated
-- applications of @f@ to @x@:
--
-- > iterate f x == [f x, f (f x), ...]
iterateTail :: (a -> a) -> a -> [a]
iterateTail f = tail . iterate f

-- | 'mkZipper' @genLeft genRight e@ returns an infinite zipper
-- focused on @e@ where left part is generated by iterating @genLeft@
-- and right part is generated by iterating @genRight@A.
mkZipper :: (a -> a) -> (a -> a) -> a -> ListZipper a
mkZipper genLeft genRight e =
  LZ (iterateTail genLeft e) e (iterateTail genRight e)

-- | Writes the item instead of the one the zipper is focused on.
listWrite :: a -> ListZipper a -> ListZipper a
listWrite x (LZ ls _ rs) = LZ ls x rs

instance Functor ListZipper where
  fmap f (LZ ls a rs) = LZ (f <$> ls) (f a) (f <$> rs)

instance Comonad ListZipper where
  extract (LZ _ a _) = a
  duplicate = mkZipper listLeft listRight

-- | 2D grid - combination of list zippers.
-- The outer zipper is the zipper of lines in grid.
newtype Grid a = Grid (ListZipper (ListZipper a))

-- | Returns the grid with the focus shifted up one element.
up :: Grid a -> Grid a
up (Grid g) = Grid (listLeft g)

-- | Returns the grid with the focus shifted down one element.
down :: Grid a -> Grid a
down (Grid g) = Grid (listRight g)

-- | Returns the grid with the focus shifted left one element.
left :: Grid a -> Grid a
left (Grid g) = Grid (fmap listLeft g)

-- | Returns the grid with the focus shifted right one element.
right :: Grid a -> Grid a
right (Grid g) = Grid (fmap listRight g)

-- | Returns element the grid is focused on.
gridRead :: Grid a -> a
gridRead (Grid g) = extract $ extract g

-- | Writes the item instead of the one the grid is focused on.
gridWrite :: a -> Grid a -> Grid a
gridWrite x (Grid g) = Grid (listWrite newLine g)
  where
    oldLine = extract g
    newLine = listWrite x oldLine

-- | Returns 'ListZipper' of horizontally shifted grids.
horizontal :: Grid a -> ListZipper (Grid a)
horizontal = mkZipper left right

-- | Returns 'ListZipper' of vertically shifted grids.
vertical :: Grid a -> ListZipper (Grid a)
vertical = mkZipper up down

instance Functor Grid where
  fmap f (Grid g) = Grid (fmap (fmap f) g)

instance Comonad Grid where
  extract :: Grid a -> a
  extract = gridRead

  duplicate :: Grid a -> Grid (Grid a)
  duplicate grid = Grid $ fmap horizontal $ vertical grid

-- | Representation of person's status in simulation.
data PersonStatus
    = Susceptible
    | Incubating Int
    | Infected Int
    | Recovered Int

instance Show PersonStatus where
  show Susceptible    = "_"
  show (Incubating _) = "%"
  show (Infected _)   = "#"
  show (Recovered _)  = "@"

-- | Representation of person in simulation.
data Person = Person { getStatus :: PersonStatus, getRng :: StdGen }

-- | Representation of simulation parameters.
data SimulationParams = SimParams
  { getProbability    :: Double   -- ^ Probability of transmission
  , getIncubPeriod    :: Int      -- ^ Days in incubation
  , getInfectPeriod   :: Int      -- ^ Days with symptoms
  , getImmunityPeriod :: Int      -- ^ Days with immunity
  }

-- | Representation of outbreak simulation.
data OutbreakSimulation = Simulation (Grid Person) SimulationParams

-- | Returns 'True' if 'Person' with specified status
-- can transmit disease.
isContagious :: PersonStatus -> Bool
isContagious status = case status of
  Incubating _ -> True
  Infected _   -> True
  _            -> False

-- | Returns number of contagious person's statuses in list.
contagiousCount :: [PersonStatus] -> Int
contagiousCount = length . filter isContagious

-- | Returns number of contagious neighbours in grid.
contagiousNeighbours :: Grid Person -> Int
contagiousNeighbours g = contagiousCount $
  map (\direction -> getStatus $ extract $ direction g) directions
  where
    directions = [left, right, up, down]

-- | Returns 'Incubating' or 'Susceptible' 'Person' depending on
-- transmission probability and number of contagious neighbours.
transmiss :: StdGen -> SimulationParams -> Grid Person -> Person
transmiss rng params g = let
  prob = getProbability params
  cnt = contagiousNeighbours g
  transmissChance = 1 - (1 - prob) ^ cnt
  (rndVal, newRng) = random rng
  in if rndVal < transmissChance
    then Person (Incubating (getIncubPeriod params)) newRng
    else Person Susceptible newRng

-- | Returns 'PersonStatus' after one step of simulation.
-- Specified status mustn't be 'Susceptible'.
notSuspectStatusRule :: PersonStatus -> SimulationParams -> PersonStatus
notSuspectStatusRule s params = case s of
  Susceptible  -> error "Susceptible status"
  Incubating 1 -> Infected (getInfectPeriod params)
  Incubating n -> Incubating (n - 1)
  Infected 1   -> Recovered (getImmunityPeriod params)
  Infected n   -> Infected (n - 1)
  Recovered 1  -> Susceptible
  Recovered n  -> Recovered (n - 1)

-- | The rule by which the 'Person" on which the 'Grid' is
-- focused  in the simulation changes in one step.
rule :: SimulationParams -> Grid Person -> Person
rule params g = let
  Person status rng = gridRead g
  in case status of
    Susceptible -> transmiss rng params g
    _           -> Person (notSuspectStatusRule status params) rng

-- | One step in 'OutbreakSimulation'.
step :: OutbreakSimulation -> OutbreakSimulation
step (Simulation grid params) =
  Simulation (extend (rule params) grid) params

-- | Initialize 'OutbreakSimulation' with passed parameters
-- and one 'Incubating' 'Person' in the center.
initSimulation :: Double -> Int -> Int -> Int -> IO OutbreakSimulation
initSimulation prob incubPeriod infectPeriod immunPeriod = do
  rng <- newStdGen
  let initPerson = Person (Incubating incubPeriod) rng
      susceptPerson = Person Susceptible rng
      susceptRow = mkZipper newGenFst newGenSnd susceptPerson
      susceptGrid = Grid $ mkZipper (fmap newGenFst) (fmap newGenSnd) susceptRow
      initGrid = gridWrite initPerson susceptGrid

  return $ Simulation initGrid
    (SimParams prob incubPeriod infectPeriod immunPeriod)
  where
    newGenFst p = Person (getStatus p) (fst $ split $ getRng p)
    newGenSnd p = Person (getStatus p) (snd $ split $ getRng p)

-- | 'showSimulation' @n simulation@ converts @simulation@ to
-- a string of @2n+1@ lines of length @2n+1@ each.
showSimulation :: Int -> OutbreakSimulation -> String
showSimulation n (Simulation grid _) = 
  unlines $ map concat $ gridToList $ fmap (show . getStatus) grid
  where 
    gridToList (Grid g) = zipperToList (fmap zipperToList g)
    zipperToList (LZ ls x rs) = (reverse $ take n ls) ++ [x] ++ take n rs
